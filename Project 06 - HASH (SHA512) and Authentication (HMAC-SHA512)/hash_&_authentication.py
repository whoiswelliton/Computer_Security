# -*- coding: utf-8 -*-
"""Hash & Authentication.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Cqpv0g67FXkgUbwqbPzFOVF9-x6IzMEw
"""

from google.colab import drive
drive.mount('/content/drive')

pip install pycryptodome

import hashlib
from Crypto.Hash import SHA512
from Crypto.Hash import HMAC
from Crypto.Random import get_random_bytes

""" - Função de Criptografia Hash utilizada -> SHA-512"""

#mensagem de entrada
Message = b"Informacao Digital Qualquer"

#chave secreta K de 16 bytes
SecretKey = get_random_bytes(16)
print(SecretKey)

"""# HASH -> SHA-512

SHA - Secure Hash Algorithm

1 - Um código de hash não usa uma chave, sendo uma função apenas da mensagem de entrada.

2 - Uma mudança em qualquer bit ou bits na mensagem resulta em uma
mudança no código de hash.

3 - H pode ser aplicado a um bloco de dados de qualquer tamanho e produz uma saída de comprimento fixo.

4 - Para qualquer valor h dado, deve ser inviável obter x.

5 - Para qualquer bloco x, deve ser inviável encontrar uma mensagem alternativa que gere o mesmo hash.

Uma função de hash mapeia uma mensagem de tamanho variável em um valor de hash de tamanho fixo, também conhecido como resumo da mensagem (message digest).

- Exemplo (a)

- Pycryptodome
"""

#criando objeto hash utilizando o modo SHA512
HASH1 = SHA512.new(Message)

#tamanho do bloco de mensagem em bytes - 512 bits
HASH1.digest_size

#tamanho da mensagem sintetizada em bytes - 1024 bits
HASH1.block_size

#retorna o binário da mensagem sintetizada mas não printável
HASH1.digest()

"""HASH 1 - Gerada com usando a mensagem inteira"""

#retorna a mensagem sintetizada/resumo
HASH1.hexdigest()

"""- Hashlib"""

HASH2 = hashlib.sha512()

HASH2.update(b"Informacao Digital")
HASH2.update(b" Qualquer")

HASH2.digest()

"""HASH 2 - Geradando a informação hash em momentos distintos da mensagem dividida"""

HASH2.hexdigest()

"""Adicionando a chave secreta como novo bloco de informação depois de já ter gerado o hash da mensagem

- [ H(M) + E(K) ] => E(K,[M || H(M)]) 
"""

E = HASH2

E.update(SecretKey)

HMAC_E = E.hexdigest()
HMAC_E

"""O destinatário possui:
- MAC Original
- Mensagem Recebida
- Secret Key
- Função SHA-512
"""

HASHDest = SHA512.new(Message)

HASHDest.hexdigest()

E2 = HASHDest

E2.update(SecretKey)

HMAC_E2 = E2.hexdigest()
HMAC_E2

#Verficação se aos dois HMAC's são iguais
HMAC_E == HMAC_E2

"""# AUTHENTICATION -> HMAC-SHA512

HMAC - Hash-based Message Authentication Code
- Depende de uma chave secreta

K -  SECRET KEY - Chave secreta compartilhada

C = função MAC (SHA512)

M = Mensagem de entrada

H - função de hash embutida

MAC = código de autenticação da mensagem

Para autenticação da mensagem, uma função de hash segura precisa ser combinada de alguma forma com uma chave secreta.

- Exemplo (b)

- H[ M + E(K) ] => E(K, H(M))
"""

#Cria um novo objeto MAC passando Chave, mensagem e modo de hash
HM = HMAC.new(SecretKey, msg = Message, digestmod = SHA512)

#retorna o MAC binário não printável da mensagem autenticada
HM.digest()

#retorna a tag MAC printável
HMAC_FINAL = HM.hexdigest()
HMAC_FINAL

"""Criando uma HMAC4 com uma "Nova Informacao" a mais"""

HM2 = HM

HM2.update(b'Nova Informacao')

HMAC_ZOADO = HM2.hexdigest()
HMAC_ZOADO

"""Validando o MAC

O destinatário possui:
- MAC Original
- Mensagem Recebida
- Secret Key
- Função SHA-512
"""

HMD = HMAC.new(SecretKey, msg = Message, digestmod = SHA512)

HM_DEST = HMD.hexdigest()
HM_DEST

"""Verificando com o HMAC Igual"""

try:
  HMD.hexverify(HMAC_FINAL)
  print("The message '%s' is authentic" % Message)
except ValueError:
  print("The message or the key is wrong")

HM_DEST == HMAC_FINAL

"""Verificando com o HMAC Diferente"""

try:
  HMD.hexverify(HMAC_ZOADO)
  print("The message '%s' is authentic" % Message)
except ValueError:
  print("The message or the key is wrong")

HM_DEST == HMAC_ZOADO