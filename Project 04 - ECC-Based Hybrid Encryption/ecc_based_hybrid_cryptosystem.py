# -*- coding: utf-8 -*-
"""ECC-Based Hybrid Cryptosystem.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1QPz_Sbqa79DY319qe0xQNGw5SboekiS2

**ECC-Based Hybrid Cryptosystem**
"""

from google.colab import drive
drive.mount('/content/drive')

pip install pycryptodome

pip install tinyec

from Crypto.PublicKey import ECC
from Crypto.Random import get_random_bytes
from Crypto.Cipher import AES, PKCS1_OAEP
from tinyec import registry
from PIL import Image
import hashlib, secrets, binascii

"""# PROCESS"""

assymetric = Image.open("/content/drive/My Drive/Cryptowork/asymmetric.gif")
assymetric

"""# KEYS

- RECEIVER KEYS
"""

#Escolhendo e utilizando a curva de 256bits
curve = registry.get_curve('secp256r1')
print('curve:', curve)

#chave privada
privKey = secrets.randbelow(curve.field.n)
#chave pública
pubKey = curve.g * privKey

print("private key:", privKey)
print("public key:", pubKey)

"""Criando o par de chaves ECC"""

publicKey = ECC.construct(curve="secp256r1", point_x = pubKey.x, point_y = pubKey.y)
privateKey = ECC.construct(curve="secp256r1", d = privKey)

print(publicKey)
print(privateKey)

#exportando a chave privada utilizando o formato PEM de codificação de texto
private_key = privateKey.export_key(format='PEM', use_pkcs8 = True)
file_out = open("/content/drive/My Drive/Cryptowork/privateECC.pem", "wt")
file_out.write(private_key)
file_out.close()

private_key

#exportando a chave pública utilizando o formato OpenSSH de codificação de texto
public_key = publicKey.export_key(format='OpenSSH', compress = False)
file_out = open("/content/drive/My Drive/Cryptowork/receiverECC.pem", "wt")
file_out.write(public_key)
file_out.close()

public_key

"""- SENDER KEYS"""

#chave do recebedor
recipient_key = ECC.import_key(open("/content/drive/My Drive/Cryptowork/receiverECC.pem").read())
print(recipient_key)

"""# ENCRYPTING (SENDER)

OBS: pubKey = recipient_key, mas tive erros tentando utilizar e com formatos, portanto utilizei o que já tinha, não a carregada do arquivo
"""

data = "Mensagem ultra super secreta usando (E)lliptic-(C)urve (C)ryptography Cryptosystem".encode("utf-8")

""" ECDH algorithm
 - (a * G) * b = (b * G) * a
 - a = privKey, a * G = pubKey, b = ciphertextPrivKey, b * G = ciphertextPubKey
 - pubKey * ciphertextPrivKey = ciphertextPubKey * privKey = sharedECCKey
"""

#cifrando nossa chave pública
#geranmos uma cifra pública e uma privada baseadas em nossa curva conhecida 
ciphertextPrivKey = secrets.randbelow(curve.field.n)
ciphertextPubKey = ciphertextPrivKey * curve.g            #ephemeral key

#criamos uma chave ECC compartilhada de criptografia simétrica, Essa chave é um ponto EC
sharedECCKey = ciphertextPrivKey * pubKey  
print(sharedECCKey)

#Transformadando em chave secreta AES de 256 bits (inteiro), por meio do hash das coordenadas x e y do ponto
sha = hashlib.sha256(int.to_bytes(sharedECCKey.x, 32, 'big'))
secretKey = sha.digest() #assimétrica
print(secretKey)

"""Modo de bloco GCM - se a chave de descriptografia ou algum outro parâmetro estiver incorreto, a descriptografia falhará com uma exceção"""

#Encriptando os dados/mensagem com a chave cifrada e o AES
aesCipher = AES.new(secretKey, AES.MODE_GCM)
ciphertext, authTag = aesCipher.encrypt_and_digest(data) #simétrica

encryptedMsg = ciphertext, aesCipher.nonce, authTag, ciphertextPubKey
print(encryptedMsg)

encryptedMsgObj = {
    'ciphertext': binascii.hexlify(encryptedMsg[0]),
    'aesCipher.nonce': binascii.hexlify(encryptedMsg[1]),
    'authTag': binascii.hexlify(encryptedMsg[2]),
    'ciphertextPubKey': hex(encryptedMsg[3].x) + hex(encryptedMsg[3].y % 2)[2:]
}

print("encrypted msg:", encryptedMsgObj)

"""# DECRYPTING (RECEIVER)

OBS: privKey = private_key1, mas tive erros tentando utilizar e com formatos, portanto utilizei o que já tinha, não a carregada do arquivo
"""

#Recebedor acessando sua chave privada
private_key1 = ECC.import_key(open("/content/drive/My Drive/Cryptowork/privateECC.pem").read())
private_key1

(ciphertext1, nonce1, authTag1, ciphertextPubKey1) = encryptedMsg

#fazemos o processo inverso, descobrindo a chave compartilhada a partir da nossa chave privada com a cifra pública recebida
sharedECCKey1 = privKey * ciphertextPubKey1
sharedECCKey1

#Usamos um ponto da curva ECC para criarmos nossa chave cifrada/secreta de 256 bits
sha = hashlib.sha256(int.to_bytes(sharedECCKey1.x, 32, 'big'))
secretKey1 = sha.digest()
print(secretKey1)

#Decriptando o AES
aesCipher = AES.new(secretKey1, AES.MODE_GCM, nonce1)
plaintext = aesCipher.decrypt_and_verify(ciphertext1, authTag1)

decryptedMsg = plaintext
print("decrypted msg:", decryptedMsg)